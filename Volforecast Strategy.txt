import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

class VolForecastStrategy:
    def __init__(self, ticker, window_vol=20, desvio_std=1.7, max_drawdown=0.25,
                 start="2020-01-01", end=None, freq="daily"):
        self.ticker = ticker
        self.window_vol = window_vol
        self.desvio_std = desvio_std
        self.max_drawdown = -abs(max_drawdown)
        self.start = start
        self.end = end
        self.freq = freq

        self.data = None
        self.sinais = None
        self.resultados = None
        self.operacoes_df = None
        self.capital = 1.0

    def baixar_dados(self):
        df = yf.download(self.ticker, start=self.start, end=self.end, auto_adjust=True)
        self.data = df['Close'].dropna()

    def gerar_sinais(self):
        precos = self.data
        media = precos.rolling(self.window_vol).mean()
        vol = precos.rolling(self.window_vol).std()
        res = media + self.desvio_std * vol
        sup = media - self.desvio_std * vol

        sinais = pd.DataFrame(index=precos.index)
        sinais['preco'] = precos
        sinais['res'] = res
        sinais['sup'] = sup
        sinais['compra'] = (precos < sup) & (precos.shift(1) >= sup.shift(1))
        sinais['venda'] = (precos > res) & (precos.shift(1) <= res.shift(1))

        self.sinais = sinais

    def simular_trades(self):
        precos = self.data
        sinais = self.sinais

        capital = 1.0
        max_capital = capital
        capital_hist = [capital]
        datas = [precos.index[0]]
        drawdowns = [0.0]
        operacoes = []
        stop_acionado = False

        for i in range(1, len(sinais) - 1):
            if stop_acionado:
                capital_hist.append(capital_hist[-1])
                datas.append(precos.index[i])
                drawdowns.append(drawdowns[-1])
                continue

            entrada = False
            lucro = 0
            tipo_op = 'hold'

            if sinais['compra'].iloc[i]:
                preco_entrada = precos.iloc[i]
                preco_saida = precos.iloc[i + 1]
                lucro = (preco_saida - preco_entrada) / preco_entrada
                tipo_op = 'compra'
                entrada = True

            elif sinais['venda'].iloc[i]:
                preco_entrada = precos.iloc[i]
                preco_saida = precos.iloc[i + 1]
                lucro = (preco_entrada - preco_saida) / preco_entrada
                tipo_op = 'venda'
                entrada = True

            if entrada:
                capital *= (1 + lucro)
                operacoes.append({
                    'data_entrada': precos.index[i],
                    'data_saida': precos.index[i + 1],
                    'tipo': tipo_op,
                    'lucro': lucro,
                    'capital_antes': capital_hist[-1],
                    'capital_depois': capital
                })

            max_capital = max(max_capital, capital)
            drawdown = (capital - max_capital) / max_capital

            capital_hist.append(capital)
            datas.append(precos.index[i + 1])
            drawdowns.append(drawdown)

            if drawdown <= self.max_drawdown:
                print(f"Stop acionado em {precos.index[i + 1]}: Drawdown {drawdown:.2%}")
                stop_acionado = True

        self.capital = capital
        self.resultados = pd.DataFrame({
            'Data': datas,
            'Capital': capital_hist,
            'Drawdown': drawdowns
        }).set_index('Data')
        self.operacoes_df = pd.DataFrame(operacoes)

    def summary(self):
        if self.resultados is None:
            print("Execute 'run()' antes de visualizar o resumo.")
            return

        retorno_total = (self.capital - 1) * 100
        max_dd = self.resultados['Drawdown'].min() * 100
        num_operacoes = len(self.operacoes_df)
        taxa_acerto = (self.operacoes_df['lucro'] > 0).mean() * 100 if num_operacoes > 0 else 0

        print("\n" + "=" * 50)
        print("Resumo do Backtest")
        print("=" * 50)
        print(f"Capital Final: {self.capital:.2f} ({retorno_total:.2f}%)")
        print(f"Drawdown Máximo: {max_dd:.2f}%")
        print(f"Número de Operações: {num_operacoes}")
        print(f"Taxa de Acerto: {taxa_acerto:.2f}%" if num_operacoes > 0 else "Taxa de Acerto: N/A")
        print("=" * 50)

        if not self.operacoes_df.empty:
            print("\nÚltimas 5 operações:")
            print(self.operacoes_df.tail().to_string(index=False))

    def plot(self):
        if self.resultados is None:
            print("Execute 'run()' antes de visualizar o gráfico.")
            return

        precos = self.data
        sinais = self.sinais

        media = precos.rolling(self.window_vol).mean()
        vol = precos.rolling(self.window_vol).std()
        res = media + self.desvio_std * vol
        sup = media - self.desvio_std * vol

        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), sharex=True, gridspec_kw={'height_ratios': [2, 1]})
        ax1.plot(precos, label='Preço', color='black', alpha=0.7)
        ax1.plot(media, label='MM20', color='blue', alpha=0.7)
        ax1.plot(res, label='Resistência', color='red', linestyle='--', alpha=0.7)
        ax1.plot(sup, label='Suporte', color='green', linestyle='--', alpha=0.7)

        if not self.operacoes_df.empty:
            compras = self.operacoes_df[self.operacoes_df['tipo'] == 'compra']
            vendas = self.operacoes_df[self.operacoes_df['tipo'] == 'venda']
            ax1.scatter(compras['data_entrada'], precos.loc[compras['data_entrada']],
                        marker='^', color='green', s=100, label='Compras')
            ax1.scatter(vendas['data_entrada'], precos.loc[vendas['data_entrada']],
                        marker='v', color='red', s=100, label='Vendas')

        ax1.set_title(f'Estratégia de Volatilidade - {self.ticker}')
        ax1.set_ylabel('Preço')
        ax1.legend()
        ax1.grid(True)

        self.resultados['Capital'].plot(ax=ax2, color='blue', label='Capital')
        ax2.axhline(y=1, color='black', linestyle='--', alpha=0.5)
        ax2.set_ylabel('Capital')
        ax2.grid(True)

        ax3 = ax2.twinx()
        ax3.fill_between(self.resultados.index, self.resultados['Drawdown'], 0,
                         where=self.resultados['Drawdown'] < 0,
                         color='red', alpha=0.3, label='Drawdown')
        ax3.set_ylabel('Drawdown')
        ax3.set_ylim(min(self.resultados['Drawdown']) * 1.1, 0)
        ax3.axhline(y=self.max_drawdown, color='darkred', linestyle='--', label='Limite DD')

        lines, labels = ax2.get_legend_handles_labels()
        lines2, labels2 = ax3.get_legend_handles_labels()
        ax3.legend(lines + lines2, labels + labels2, loc='lower left')

        plt.suptitle(f'Backtest | Retorno: {(self.capital - 1) * 100:.2f}% | Max DD: {self.resultados["Drawdown"].min() * 100:.2f}%')
        plt.tight_layout()
        plt.show()

    def run(self):
        self.baixar_dados()
        self.gerar_sinais()
        self.simular_trades()
